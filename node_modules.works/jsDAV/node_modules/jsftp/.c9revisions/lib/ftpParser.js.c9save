{"ts":1353668175335,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * @package jsftp\n * @copyright Copyright(c) 2011 Ajax.org B.V. <info AT ajax DOT org>\n * @author Sergi Mansilla <sergi.mansilla@gmail.com>\n * @license https://github.com/sergi/jsFTP/blob/master/LICENSE MIT License\n *\n * See RFC at http://www.w3.org/Protocols/rfc959\n *\n */\n\n\"use strict\";\nvar RE_SERVER_RESPONSE = /^(\\d\\d\\d)(.*)/;\nvar RE_MULTI_RESPONSE = /^(\\d\\d\\d)-/;\n\n/**\n * this is the regular expression used by Unix Parsers.\n *\n * Permissions:\n *    r   the file is readable\n *    w   the file is writable\n *    x   the file is executable\n *    -   the indicated permission is not granted\n *    L   mandatory locking occurs during access (the set-group-ID bit is\n *        on and the group execution bit is off)\n *    s   the set-user-ID or set-group-ID bit is on, and the corresponding\n *        user or group execution bit is also on\n *    S   undefined bit-state (the set-user-ID bit is on and the user\n *        execution bit is off)\n *    t   the 1000 (octal) bit, or sticky bit, is on [see chmod(1)], and\n *        execution is on\n *    T   the 1000 bit is turned on, and execution is off (undefined bit-\n *        state)\n */\n\nvar RE_UnixEntry = new RegExp(\n    \"([bcdlfmpSs-])\"\n    + \"(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-])))\\\\+?\\\\s+\"\n    + \"(\\\\d+)\\\\s+\"\n    + \"(\\\\S+)\\\\s+\"\n    + \"(?:(\\\\S+)\\\\s+)?\"\n    + \"(\\\\d+)\\\\s+\"\n\n    //numeric or standard format date\n    + \"((?:\\\\d+[-/]\\\\d+[-/]\\\\d+)|(?:\\\\S+\\\\s+\\\\S+))\\\\s+\"\n\n    // year (for non-recent standard format)\n    // or time (for numeric or recent standard format)\n    + \"(\\\\d+(?::\\\\d+)?)\\\\s*\"\n\n    //+ \"(\\\\S*)(\\\\s*.*)\"\n    + \"(.*)\"\n);\n\n// MSDOS format\n// 04-27-00  09:09PM       <DIR>          licensed\n// 07-18-00  10:16AM       <DIR>          pub\n// 04-14-00  03:47PM                  589 readme.htm\nvar RE_DOSEntry = new RegExp(\n    \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+\"\n    + \"(<DIR>)?\\\\s*\"\n    + \"([0-9]+)?\\\\s*\"\n    + \"(\\\\S.*)\"\n);\n\n// Not used for now\n// var RE_VMSEntry = new RegExp(\n//     \"(.*;[0-9]+)\\\\s*\"\n//     + \"(\\\\d+)/\\\\d+\\\\s*\"\n//     + \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+\"\n//     + \"\\\\[(([0-9$A-Za-z_]+)|([0-9$A-Za-z_]+),([0-9$a-zA-Z_]+))\\\\]?\\\\s*\"\n//     + \"\\\\([a-zA-Z]*,[a-zA-Z]*,[a-zA-Z]*,[a-zA-Z]*\\\\)\"\n// );\n\n// var MONTHS = [null, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nexports.nodeTypes = {\n    FILE_TYPE          : 0,\n    DIRECTORY_TYPE     : 1,\n    SYMBOLIC_LINK_TYPE : 2,\n    UNKNOWN_TYPE       : 3\n};\n\nexports.permissions = {\n    READ_PERMISSION    : 0,\n    WRITE_PERMISSION   : 1,\n    EXECUTE_PERMISSION : 2\n};\n\nexports.access = {\n    USER_ACCESS  : 0,\n    GROUP_ACCESS : 1,\n    WORLD_ACCESS : 2\n};\n\n/**\n * Selects which parser to use depending on the first character of the line to\n * parse.\n *\n * @param entry {String} FTP file entry line\n * @returns {Object} Parsed object with the file entry properties\n */\nexports.entryParser = function(entry) {\n    // Some servers include an official code-multiline sign at the beginning of\n    // every string. We must strip it if that's the case.\n    if (RE_MULTI_RESPONSE.test(entry))\n        entry = entry.substr(3);\n\n    entry = entry.trim();\n    var c = entry.charAt(0);\n\n    //if c == '+':\n    //    return self._parse_EPLF(buf)\n\n    // Filter file-listing results from 'STAT' command, since they include\n    // server responses before and after the file listing.\n    // Issue: https://github.com/sergi/jsftp/issues/3\n    if (RE_SERVER_RESPONSE.test(entry) || RE_MULTI_RESPONSE.test(entry))\n        return null;\n\n    if ('bcdlps-'.indexOf(c) > -1) {\n        console.log(\"ASDASD\")\n        return parsers.unix(entry);\n    }\n    else if ('0123456789'.indexOf(c) > -1) {\n        console.log(\"ASD\")\n        return parsers.msdos(entry);\n    }\n    else {\n        console.log(\"Unrecognized format: \\n\" + entry);\n        return null;\n    }\n};\n\nvar parsers = {};\n\nparsers.unix = function(entry) {\n    var target, writePerm, readPerm, execPerm;\n    var group = entry.match(RE_UnixEntry);\n\n    if (group) {\n        var type = group[1];\n        var hardLinks = group[15];\n        var usr = group[16];\n        var grp = group[17];\n        var size = group[18];\n        var name = group[21];\n\n        var date;\n        // Check whether we are given the time (recent file) or the year\n        // (older file) in the file listing.\n        if (group[20].indexOf(\":\") === -1) {\n            date = +new Date(group[19] + \" \" + group[20]).getTime();\n        }\n        else {\n            var currentMonth = new Date().getMonth();\n            var month = new Date(group[19]).getMonth();\n            var year = new Date().getFullYear() - (currentMonth < month ? 1 : 0);\n\n            date = +new Date(group[19] + \" \" + group[20] + \" \" + year);\n        }\n\n        // Ignoring '.' and '..' entries for now\n        if (name === \".\" || name === \"..\")\n            return;\n\n        var endtoken = group[22];\n\n        switch (type[0]) {\n            case 'd':\n                type = exports.nodeTypes.DIRECTORY_TYPE;\n                break;\n            case 'l':\n                type = exports.nodeTypes.SYMBOLIC_LINK_TYPE;\n                var isLink = /(.*)\\s->\\s(.*)/.exec(name);\n                if (isLink) {\n                    name   = isLink[1];\n                    target = isLink[2];\n                }\n                break;\n            case 'b':\n            case 'c':\n                // break; - fall through\n            case 'f':\n            case '-':\n                type = exports.nodeTypes.FILE_TYPE;\n                break;\n            default:\n                type = exports.nodeTypes.UNKNOWN_TYPE;\n        }\n\n        var file = {\n            name: name,\n            type: type,\n            time: date,\n            size: size,\n            owner: usr,\n            group: grp\n        };\n\n        if (target) file.target = target;\n\n        var g = 4;\n        [\"user\", \"group\", \"other\"].forEach(function(access) {\n            // Use != '-' to avoid having to check for suid and sticky bits\n            readPerm  = group[g] !== \"-\";\n            writePerm = group[g + 1] !== \"-\";\n\n            var execPermStr = group[g + 2];\n\n            file[access + \"Permissions\"] = {\n                read : readPerm,\n                write: writePerm,\n                exec : (execPermStr !== \"-\") && !(/[A-Z]/.test(execPermStr[0]))\n            };\n\n            g +=4;\n        });\n\n        return file;\n    }\n};\n\nparsers.msdos = function(entry) {\n    console.log(\"****\")\n    var group = entry.match(RE_DOSEntry);\n    var type;\n\n    if (!group)\n        return;\n\n    var replacer = function replacer(str, hour, min, ampm, offset, s) {\n        return hour + \":\" + min + \" \" + ampm;\n    }\n    var time = group[2].replace(/(\\d{2}):(\\d{2})([AP]M)/, replacer);\n    var date = new Date(group[1] + \" \" + time).getTime();\n    var dirString = group[3];\n    var size = group[4];\n    var name = group[5];\n\n    if (null == name || name === \".\" || name === \"..\")\n        return null;\n\n    if (dirString === \"<DIR>\") {\n        type = exports.nodeTypes.DIRECTORY_TYPE;\n        size = 0;\n    }\n    else {\n        type = exports.nodeTypes.FILE_TYPE;\n    }\n\n    return {\n        name: name,\n        type: type,\n        time: date,\n        size: size\n    };\n};\n\n/*\n * MLSx commands are not being used for now.\n *\n * http://rfc-ref.org/RFC-TEXTS/3659/chapter7.html\n * http://www.rhinosoft.com/newsletter/NewsL2005-07-06.asp?prod=rs\n *\nvar reKV = /(.+?)=(.+?);/;\nexports.parseMList = function(line) {\n    var ret;\n    var result = line.trim().split(reKV);\n\n    if (result && result.length > 0) {\n        ret = {};\n        if (result.length === 1) {\n            ret.name = result[0].trim();\n        }\n        else {\n            var i, k, v, len = result.length;\n            for (i = 1; i < len; i += 3) {\n                k = result[i];\n                v = result[i+1];\n                ret[k] = v;\n            }\n            ret.name = result[result.length-1].trim();\n        }\n    } else\n        ret = line;\n\n    return ret;\n}\n*/\n"]],"start1":0,"start2":0,"length1":0,"length2":7947}]],"length":7947}
{"contributors":[],"silentsave":false,"ts":1353668222427,"patch":[[{"diffs":[[0,") {\n"],[-1,"        console.log(\"ASDASD\")\n"],[0,"    "]],"start1":3531,"start2":3531,"length1":38,"length2":8},{"diffs":[[0,") {\n"],[-1,"        console.log(\"ASD\")\n"],[0,"    "]],"start1":3618,"start2":3618,"length1":35,"length2":8},{"diffs":[[0,"1];\n        "],[1,"//"],[0,"var hardLink"]],"start1":3948,"start2":3948,"length1":24,"length2":26},{"diffs":[[0,"n;\n\n        "],[1,"//"],[0,"var endtoken"]],"start1":4768,"start2":4768,"length1":24,"length2":26},{"diffs":[[0,") {\n"],[-1,"    console.log(\"****\")\n"],[0,"    "]],"start1":6332,"start2":6332,"length1":32,"length2":8},{"diffs":[[0," ampm;\n    }"],[1,";\n    "],[0,"\n    var tim"]],"start1":6537,"start2":6537,"length1":24,"length2":30}]],"length":7876,"saved":false}
